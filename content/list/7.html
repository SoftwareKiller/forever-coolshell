<!DOCTYPE html><!--[if IE 8]>
<html id="ie8" dir="ltr" lang="zh-CN"
	prefix="og: https://ogp.me/ns#" >
<![endif]--><!--[if !(IE 8) ]><!--><html dir="ltr" lang="zh-CN" prefix="og: https://ogp.me/ns#"><!--<![endif]--><head><meta charset="UTF-8"/><title>酷壳 – CoolShell.cn - Part 7</title><link rel="stylesheet" type="text/css" href="/assets/all.min.css"/><link rel="shortcut icon" href="/assets/favicon.png"/></head>
<body class="home blog paged paged-7 group-blog">

<div id="page" class="hfeed site">
<header id="masthead" role="banner">

<div id="cc_spacer"></div>
<div class="site-header">

<div class="site-branding">
<a class="home-link" href="/" title="酷 壳 – CoolShell" rel="home">
<h1 class="site-title">酷 壳 – CoolShell</h1>
<h2 class="site-description">享受编程和技术所带来的快乐 – Coding Your Ambition</h2>
</a>
</div>
</div>
</header>
<div class="container">
<div class="row">

</div>
</div>
<div id="content" class="site-content">
<div class="container">
<div class="row">
<div id="primary" class="content-area  col-md-12" style="margin-top: 40px;">
<main id="main" class="site-main" role="main">
<article id="post-17416" class="post-content post-17416 post type-post status-publish format-standard hentry category-unixlinux category-progdesign tag-cache tag-design tag-design-pattern tag-linux">
<header class="entry-header">
<span class="screen-reader-text">缓存更新的套路</span>
<h2 class="entry-title">
<a href="/articles/17416.html" rel="bookmark">缓存更新的套路</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17416.html" title="16:25" rel="bookmark"><time class="entry-date" datetime="2016-07-27T16:25:28+08:00" pubdate="">2016年07月27日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17416.html#comments" class="comments-link">186 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 293,389 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" class="alignright size-medium wp-image-17422" src="/uploads/2016/07/cache-300x158.png" alt="cache" width="300" height="158" srcset="" sizes="(max-width: 300px) 100vw, 300px"/>看到好些人在写更新缓存数据代码时，<strong>先删除缓存，然后再更新数据库</strong>，而后续的操作会把数据再装载的缓存中。<strong>然而，这个是逻辑是错误的</strong>。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
<p>我不知道为什么这么多人用的都是这个逻辑，当我在微博上发了这个贴以后，我发现好些人给了好多非常复杂和诡异的方案，所以，我想写这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。</p>
<p>这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。</p>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。</p>
<p> <a href="/articles/17416.html#more-17416" class="more-link">…</a></p><a href="/articles/17416.html#more-17416" class="more-link">
</a><p class="read-more"><a href="/articles/17416.html#more-17416" class="more-link"></a><a class="btn btn-default" href="/articles/17416.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17416-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17391" class="post-content post-17391 post type-post status-publish format-standard hentry category-misc tag-blog tag-search tag-803 tag-804 tag-648">
<header class="entry-header">
<span class="screen-reader-text">为什么我不在微信公众号上写文章</span>
<h2 class="entry-title">
<a href="/articles/17391.html" rel="bookmark">为什么我不在微信公众号上写文章</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17391.html" title="09:08" rel="bookmark"><time class="entry-date" datetime="2016-07-11T09:08:40+08:00" pubdate="">2016年07月11日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17391.html#comments" class="comments-link">259 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 151,091 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" class="alignright size-medium wp-image-17394" src="/uploads/2016/07/Community-300x161.jpg" alt="Community" width="300" height="161" srcset="" sizes="(max-width: 300px) 100vw, 300px"/>很多朋友问我为什么不在微信公众号上写文章。我都没有直接回答，老实说，我也是扭扭捏捏的，才去开了个个人的微信的公众号，而且还只是为了使用微服小程序，和文章的发布通知，我承认现在的阅读都在移动端，而且微信的公众号是国内移动端的文章流量及分享的入口，但是我还是更愿意使用blog这样的方式分享文章，最多也是在blog这边写好文章后，再去微信公众号那边通知一下。这个原因，不是因为我是一个老顽固，有习惯思维，而是，我不觉得微信公众号是一个好的信息传播和交流的平台。</p>
<p><strong>我下面的言论仅仅代表我的个人观点，我不想强加给别人，我只是想说明一下为什么我不把我的blog迁移到微信公众号上。</strong></p>
<p>首先，互联网是开放和共享的，不是封闭的。信息的传播更是需要开放的，大家可以看看<a href="/articles/11928.html" target="_blank" rel="noopener noreferrer">互联网之子</a>。</p>
<ul>
<li>我希望我的文章能够被rss feed到各种阅读器中。</li>
<li>我希望我的文章能有更长的生命周期，长到十几年前的文章都会有人来读。</li>
<li>我希望我的文章可以被搜索引擎所检索到。</li>
<li>我希望我的文章能被别人整理，与其它人的文章放在一起互补并引用。</li>
<li>我希望我的文章能被修改，因为文章会有错误，也会需要时常更新。</li>
</ul>
<p>然而，微信公众号都不能很好的支持。我希望我的文章能成为生态圈的里的一部份。所谓生态圈是相互融合，不是唯我独尊。这个和做开源软件的道理一样，开源软件不是把源代码开出来就好了，而是要去和已有的其它软件互相融合，互相兼容，互相支持，这本就是软件设计的真谛（参看《UNIX编程艺术》）。所以，我想，写文章也一样。</p>
<p>下面是我觉得文章传播的姿势。</p>
<p> <a href="/articles/17391.html#more-17391" class="more-link">…</a></p><a href="/articles/17391.html#more-17391" class="more-link">
</a><p class="read-more"><a href="/articles/17391.html#more-17391" class="more-link"></a><a class="btn btn-default" href="/articles/17391.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17391-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17381" class="post-content post-17381 post type-post status-publish format-standard hentry category-process category-progdesign tag-performance tag-test">
<header class="entry-header">
<span class="screen-reader-text">性能测试应该怎么做？</span>
<h2 class="entry-title">
<a href="/articles/17381.html" rel="bookmark">性能测试应该怎么做？</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17381.html" title="01:03" rel="bookmark"><time class="entry-date" datetime="2016-07-06T01:03:26+08:00" pubdate="">2016年07月06日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17381.html#comments" class="comments-link">77 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 119,273 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" class="alignright size-full wp-image-17383" src="/uploads/2016/07/PerfTest.png" alt="PerfTest" width="300" height="277" srcset="" sizes="(max-width: 300px) 100vw, 300px"/>偶然间看到了阿里中间件<a href="http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A" target="_blank">Dubbo的性能测试报告</a>，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。</p>
<p>首先，这份测试报告里的主要问题如下：</p>
<p><strong>1）用的全是平均值</strong>。老实说，平均值是非常不靠谱的。</p>
<p><strong>2）响应时间没有和吞吐量TPS/QPS挂钩</strong>。而只是测试了低速率的情况，这是完全错误的。</p>
<p><strong>3）响应时间和吞吐量没有和成功率挂钩。</strong></p>
<p> <a href="/articles/17381.html#more-17381" class="more-link">…</a></p><a href="/articles/17381.html#more-17381" class="more-link">
</a><p class="read-more"><a href="/articles/17381.html#more-17381" class="more-link"></a><a class="btn btn-default" href="/articles/17381.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17381-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17295" class="post-content post-17295 post type-post status-publish format-standard hentry category-550 category-misc tag-division-of-labour tag-manager tag-programmer">
<header class="entry-header">
<span class="screen-reader-text">让我们来谈谈分工</span>
<h2 class="entry-title">
<a href="/articles/17295.html" rel="bookmark">让我们来谈谈分工</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17295.html" title="12:55" rel="bookmark"><time class="entry-date" datetime="2015-12-13T12:55:52+08:00" pubdate="">2015年12月13日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17295.html#comments" class="comments-link">122 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 97,347 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" class="alignright size-full wp-image-17298" src="/uploads/2015/12/Division_of_Labour.jpeg" alt="Division of Labour" width="311" height="210" srcset="" sizes="(max-width: 311px) 100vw, 311px"/>昨天，我看到<a href="http://spectrum.ieee.org/view-from-the-valley/computing/software/yahoos-engineers-move-to-coding-without-a-net" target="_blank">一个新闻</a>——雅虎取消了QA团队，工程师必须自己负责代码质量，并使用持续集成代替QA。 同时，也听到网友说，“听微软做数据库运维的工程师介绍，他们也是把运维工程师和测试工程师取消了，由开发全部完成。每个人都是全栈工程师”。于是，我顺势引用了几年前写过一篇文章《<a href="/articles/6994.html" target="_blank">我们需要专职的QA吗？</a>》，并且又鼓吹了一下全栈。当然，一如既往的得到了一些的争议和嘲弄;-)。</p>
<p>有人认为取消QA基本上是公司没钱的象征，这个观点根本不值一驳，属于井底之蛙。有人认为，社会分工是大前提，并批评我说怎么不说把所有的事全干的，把我推向了另外一个极端。另外，你千万不要以为有了分工，QA的工作就保得住了。</p>
<p>就像《乔布斯传》中乔布斯质疑财务制度的时候说的，有时候，很多人都不问为什么，觉得存在的东西都是理所应当的东西。让我们失去了独立思考的机会。分工也是一样。</p>
<p>所以，为了说完整分工这个逻辑。请大家耐住性子，让我就先来谈谈“分工的优缺点”吧。</p>
<p> <a href="/articles/17295.html#more-17295" class="more-link">…</a></p><a href="/articles/17295.html#more-17295" class="more-link">
</a><p class="read-more"><a href="/articles/17295.html#more-17295" class="more-link"></a><a class="btn btn-default" href="/articles/17295.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17295-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17225" class="post-content post-17225 post type-post status-publish format-standard hentry category-cplusplus category-datebase category-progdesign category-funny tag-algorithm tag-filter tag-hashing tag-795">
<header class="entry-header">
<span class="screen-reader-text">Cuckoo Filter：设计与实现</span>
<h2 class="entry-title">
<a href="/articles/17225.html" rel="bookmark">Cuckoo Filter：设计与实现</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17225.html" title="09:18" rel="bookmark"><time class="entry-date" datetime="2015-09-02T09:18:54+08:00" pubdate="">2015年09月02日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/articles/author/full_of_bull" title="View all posts by Leo" rel="author">Leo</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17225.html#comments" class="comments-link">37 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 68,784 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><strong>（感谢网友 </strong><a href="http://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p><img decoding="async" loading="lazy" class="alignright wp-image-17243 size-medium" src="/uploads/2015/08/cuckoo-300x164.jpg" alt="" width="300" height="164" srcset="" sizes="(max-width: 300px) 100vw, 300px"/></p>
<p>对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。</p>
<p>索引的存储又分为有序和无序，前者使用关联式容器，比如B树，后者使用哈希算法。这两类算法各有优劣：比如，关联式容器时间复杂度稳定O(logN)，且支持范围查询；又比如哈希算法的查询、增删都比较快O(1)，但这是在理想状态下的情形，遇到碰撞严重的情况，哈希算法的时间复杂度会退化到O(n)。因此，选择一个好的哈希算法是很重要的。</p>
<p>时下一个非常流行的哈希索引结构就是<strong><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank">bloom filter</a></strong>，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank">来源wikipedia</a>），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。</p>
<p><img decoding="async" loading="lazy" class="aligncenter size-full wp-image-17242" src="/uploads/2015/08/Bloom_filter.png" alt="Bloom_filter" width="649" height="233" srcset="" sizes="(max-width: 649px) 100vw, 649px"/></p>
<p> <a href="/articles/17225.html#more-17225" class="more-link">…</a></p><a href="/articles/17225.html#more-17225" class="more-link">
</a><p class="read-more"><a href="/articles/17225.html#more-17225" class="more-link"></a><a class="btn btn-default" href="/articles/17225.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17225-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17200" class="post-content post-17200 post type-post status-publish format-standard hentry category-unixlinux category-operatingsystem category-misc tag-device-mapper tag-docker tag-linux tag-thin-provisioning">
<header class="entry-header">
<span class="screen-reader-text">Docker基础技术：DeviceMapper</span>
<h2 class="entry-title">
<a href="/articles/17200.html" rel="bookmark">Docker基础技术：DeviceMapper</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17200.html" title="08:21" rel="bookmark"><time class="entry-date" datetime="2015-08-26T08:21:09+08:00" pubdate="">2015年08月26日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17200.html#comments" class="comments-link">25 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 73,801 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" class="alignright size-medium wp-image-17217" src="/uploads/2015/08/how_to_set_up_an_iSCSI_LUN_with_thin-300x150.jpg" alt="how_to_set_up_an_iSCSI_LUN_with_thin" width="300" height="150" srcset="" sizes="(max-width: 300px) 100vw, 300px"/>在上一篇<a href="/articles/17061.html" target="_blank">介绍AUFS的文章</a>中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。</p>
<h4>Device Mapper 简介</h4>
<p>DeviceMapper自Linux 2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p>
<p>Mapped Device 是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。</p>
<p>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。</p>
<p> <a href="/articles/17200.html#more-17200" class="more-link">…</a></p><a href="/articles/17200.html#more-17200" class="more-link">
</a><p class="read-more"><a href="/articles/17200.html#more-17200" class="more-link"></a><a class="btn btn-default" href="/articles/17200.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17200-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17061" class="post-content post-17061 post type-post status-publish format-standard hentry category-unixlinux category-operatingsystem category-misc tag-aufs tag-docker tag-linux tag-unionfs">
<header class="entry-header">
<span class="screen-reader-text">Docker基础技术：AUFS</span>
<h2 class="entry-title">
<a href="/articles/17061.html" rel="bookmark">Docker基础技术：AUFS</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17061.html" title="08:01" rel="bookmark"><time class="entry-date" datetime="2015-08-24T08:01:13+08:00" pubdate="">2015年08月24日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17061.html#comments" class="comments-link">42 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 92,537 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><a href="https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw.png"><img decoding="async" loading="lazy" class="alignright size-medium wp-image-17194" src="/uploads/2015/08/docker-filesystems-busyboxrw-300x225.png" alt="docker-filesystems-busyboxrw" width="300" height="225" srcset="" sizes="(max-width: 300px) 100vw, 300px"/></a>AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。</p>
<p>AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。</p>
<p>不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。</p>
<p>好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）</p>
<p> <a href="/articles/17061.html#more-17061" class="more-link">…</a></p><a href="/articles/17061.html#more-17061" class="more-link">
</a><p class="read-more"><a href="/articles/17061.html#more-17061" class="more-link"></a><a class="btn btn-default" href="/articles/17061.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17061-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17049" class="post-content post-17049 post type-post status-publish format-standard hentry category-unixlinux category-operatingsystem category-misc tag-cgroup tag-docker tag-linux">
<header class="entry-header">
<span class="screen-reader-text">Docker基础技术：Linux CGroup</span>
<h2 class="entry-title">
<a href="/articles/17049.html" rel="bookmark">Docker基础技术：Linux CGroup</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17049.html" title="09:03" rel="bookmark"><time class="entry-date" datetime="2015-04-17T09:03:57+08:00" pubdate="">2015年04月17日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17049.html#comments" class="comments-link">87 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 124,545 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" src="/uploads/2015/04/filter.png" alt="filter" width="224" height="225" class="alignright size-full wp-image-17097" srcset="" sizes="(max-width: 224px) 100vw, 224px"/>前面，我们介绍了<a title="Docker基础技术：Linux Namespace" href="/articles/17010.html" target="_blank">Linux Namespace</a>，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。</p>
<p>Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。</p>
<p>Linux CGroupCgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。</p>
<p>主要提供了如下功能：</p>
<p> <a href="/articles/17049.html#more-17049" class="more-link">…</a></p><a href="/articles/17049.html#more-17049" class="more-link">
</a><p class="read-more"><a href="/articles/17049.html#more-17049" class="more-link"></a><a class="btn btn-default" href="/articles/17049.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17049-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17010" class="post-content post-17010 post type-post status-publish format-standard hentry category-unixlinux tag-docker tag-linux tag-mount tag-namespace">
<header class="entry-header">
<span class="screen-reader-text">Docker基础技术：Linux Namespace（上）</span>
<h2 class="entry-title">
<a href="/articles/17010.html" rel="bookmark">Docker基础技术：Linux Namespace（上）</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17010.html" title="10:20" rel="bookmark"><time class="entry-date" datetime="2015-04-16T10:20:08+08:00" pubdate="">2015年04月16日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17010.html#comments" class="comments-link">113 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 241,619 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" class="alignright size-full wp-image-17085" src="/uploads/2015/04/isolation.jpg" alt="isolation" width="359" height="237" srcset="" sizes="(max-width: 359px) 100vw, 359px"/>时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New “Old Stuff”。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。</p>
<p>当然，文章的风格一定会尊重时下的“流行”——<strong>我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间</strong>（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）</p>
<p>废话少说，我们开始。先从Linux Namespace开始。</p>
<h4> 简介</h4>
<p>Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p>
<p> <a href="/articles/17010.html#more-17010" class="more-link">…</a></p><a href="/articles/17010.html#more-17010" class="more-link">
</a><p class="read-more"><a href="/articles/17010.html#more-17010" class="more-link"></a><a class="btn btn-default" href="/articles/17010.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17010-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<article id="post-17029" class="post-content post-17029 post type-post status-publish format-standard hentry category-unixlinux category-operatingsystem tag-docker tag-linux tag-namespace">
<header class="entry-header">
<span class="screen-reader-text">Docker基础技术：Linux Namespace（下）</span>
<h2 class="entry-title">
<a href="/articles/17029.html" rel="bookmark">Docker基础技术：Linux Namespace（下）</a>
</h2>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/17029.html" title="10:19" rel="bookmark"><time class="entry-date" datetime="2015-04-16T10:19:23+08:00" pubdate="">2015年04月16日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/haoel" title="View all posts by 陈皓" rel="author">陈皓</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/17029.html#comments" class="comments-link">51 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 98,208 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><img decoding="async" loading="lazy" class="alignright size-full wp-image-17084" src="/uploads/2015/04/jail_cell.jpg" alt="jail_cell" width="350" height="252" srcset="" sizes="(max-width: 350px) 100vw, 350px"/>在 <strong><a title="Docker基础技术：Linux Namespace（上）" href="/articles/17010.html" target="_blank" rel="noopener noreferrer">Docker基础技术：Linux Namespace（上篇）</a></strong>中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。</p>
<p>好，下面我们就介绍一下还剩下的这两个Namespace。</p>
<h4>User Namespace</h4>
<p>User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/&lt;pid&gt;/uid_map</strong> 和 <strong>/proc/&lt;pid&gt;/gid_map</strong> 这两个文件。这两个文件的格式为：</p>
<p><code></code><code></code><strong>ID-inside-ns ID-outside-ns length</strong></p>
<p>其中：</p>
<p> <a href="/articles/17029.html#more-17029" class="more-link">…</a></p><a href="/articles/17029.html#more-17029" class="more-link">
</a><p class="read-more"><a href="/articles/17029.html#more-17029" class="more-link"></a><a class="btn btn-default" href="/articles/17029.html"> 阅读全文<span class="screen-reader-text"> Read More</span></a></p>
<p></p>
<div id="post-ratings-17029-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
</footer>
</article>
<nav class="navigation posts-navigation" role="navigation">
<h2 class="screen-reader-text">Posts navigation</h2>
<div class="nav-links">
<div class="row">
<div class="wp-pagenavi" role="navigation">
<span class="pages">第 7 / 74 页</span><a class="first" aria-label="First Page" href="/">« 首页</a><a class="previouspostslink" rel="prev" aria-label="上一页" href="/page/6.html">«</a><span class="extend">...</span><a class="page smaller" title="第 3 页" href="/page/3.html">3</a><a class="page smaller" title="第 4 页" href="/page/4.html">4</a><a class="page smaller" title="第 5 页" href="/page/5.html">5</a><a class="page smaller" title="第 6 页" href="/page/6.html">6</a><span aria-current="page" class="current">7</span><a class="page larger" title="第 8 页" href="/page/8.html">8</a><a class="page larger" title="第 9 页" href="/page/9.html">9</a><a class="page larger" title="第 10 页" href="/page/10.html">10</a><a class="page larger" title="第 11 页" href="/page/11.html">11</a><a class="page larger" title="第 12 页" href="/page/12.html">12</a><span class="extend">...</span><a class="larger page" title="第 20 页" href="/page/20.html">20</a><a class="larger page" title="第 30 页" href="/page/30.html">30</a><a class="larger page" title="第 40 页" href="/page/40.html">40</a><a class="larger page" title="第 50 页" href="/page/50.html">50</a><a class="larger page" title="第 60 页" href="/page/60.html">60</a><span class="extend">...</span><a class="nextpostslink" rel="next" aria-label="下一页" href="/page/8.html">»</a><a class="last" aria-label="Last Page" href="/page/74.html">末页 »</a>
</div>
</div>
</div>
</nav>
</main>
</div>

</div>
</div>

</div>

</div>
















</body></html>